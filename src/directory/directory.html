<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Attendee Directory</title>
  <style>
    body { 
      font-family: 'Courier New', monospace;
      background-color: #000;
      color: #0f0;
      font-size: 16px;
      line-height: 1.2;
      padding: 12px 24px;
    }
    table { 
      border-collapse: collapse;
      width: 100%;
      background-color: #000;
      font-size: 20px;
      font-weight: 600;
      border: 1px solid #0f0;
    }
    th, td { 
      padding: 8px;
      text-align: left; 
      border: 1px solid #0f0;
    }
    th { 
      background-color: #020;
      color: #0f0;
      font-weight: bold;
    }
    tr:hover { 
      background-color: #010; 
      cursor: pointer;
    }
    .search-box {
      width: 100%;
      padding: 8px;
      margin: 4px 0;
      font-family: 'Courier New', monospace;
      font-size: 18px;
      background-color: #000;
      border: 1px solid #0f0;
      color: #f0f;
      box-sizing: border-box;
      padding-right: 60px;
    }
    .search-box:focus {
      outline: none;
      border-color: #0f0;
      box-shadow: 0 0 5px #0f0;
    }
    .search-box::placeholder {
      color: rgb(0, 114, 0);
    }
    .details {
      background-color: #000 !important;
    }
    .detail-label {
      font-family: 'Courier New', monospace;
      color: #0a0;
    }
    .detail-value {
      color: #0f0;
      font-weight: bold;
    }
    
    .highlight {
      color: #ff00ff;
      font-weight: bold;
      font-size: 120%;
      padding: 0 0px;
      margin: 0 0px;
      border: none;
      display: inline-block;
      position: relative;
      text-shadow: 0 0 8px #8a008a;
    }

    h1 {
      font-family: 'Courier New', monospace;
      font-size: 24px;
      font-weight: bold;
      text-align: center;
      margin: 0;
      text-transform: uppercase;
      background: repeating-linear-gradient(
        0deg,
        #0c0,
        #0c0 2px,
        #0b0 2px,
        #0b0 4px
      );
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: scanline-text 100s linear infinite;
    }
    a {
      color: #00ffff;
      text-decoration: none;
    }
    a:hover {
      background-color: #00ffff;
      color: #000;
    }
    
    a[href]:not(:hover) {
      text-decoration: underline;
      text-underline-offset: 2px;
    }
    
    .search-container {
      border: 2px solid #0f0;
      padding: 10px;
      margin-bottom: 20px;
    }
    
    @keyframes scanline {
      0% {
        background-position: 0 -100vh;
      }
      100% {
        background-position: 0 100vh;
      }
    }

    body::after {
      content: "";
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: linear-gradient(
        0deg,
        rgba(0, 255, 0, 0.03) 50%,
        transparent 50%
      );
      background-size: 100% 4px;
      pointer-events: none;
      animation: scanline 10s linear infinite;
    }

    * {
      text-shadow: 0 0 5px rgba(0, 255, 0, 0.3);
    }

    .details-item {
      margin-bottom: 1em;
    }

    .details-item:last-child {
      margin-bottom: 0;
      border-bottom: none;
    }

    .selected-row {
      background-color: #020;
    }

    .arrow-indicator {
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 24px;
      color: #0f0;
      user-select: none;
    }

    td {
      position: relative;
      padding-right: 40px;
    }

    @keyframes scanline-text {
      0% {
        background-position: 0 0;
      }
      100% {
        background-position: 0 100px;
      }
    }

    @media (max-width: 768px) {
      .search-container h1,
      .search-container div[style*="color: #0a0"] {
        transition: opacity 0.2s, margin 0.2s;
      }
      
      .search-container.focused h1,
      .search-container.focused div[style*="color: #0a0"] {
        opacity: 0;
        margin: 0;
        height: 0;
        overflow: hidden;
      }
    }

    .search-wrapper {
      position: relative;
      width: 100%;
    }

    .clear-button {
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      background: none;
      border: none;
      color: #00ffff;  /* Changed from #0f0 to cyan */
      cursor: pointer;
      font-family: 'Courier New', monospace;
      padding: 4px 8px;
      display: none;
      text-decoration: none;
    }

    .clear-button:hover {
      color: #f0f;
      background-color: transparent;
    }

    .details a:focus {
      background-color: #00ffff;
      color: #000;
      outline: none;
    }

    tr:focus {
      outline: none;
    }

    tr:not(.details):focus {
      background-color: #020;
    }

    /* Remove any lingering background color when focus is lost */
    tr:not(.details):not(:focus):not(.selected-row) {
      background-color: transparent;
    }
  </style>
</head>
<body>
  <div class="search-container">
    <h1>2025 Go Congress Directory</h1>
    <div style="color: #0a0; font-size: 14px; text-align: center; margin: 0; padding: 0;">Confidential. Do not share. Authorized use only.</div>
    <div class="search-wrapper">
      <input type="text" class="search-box" placeholder="Name, phone number, email, language..." id="searchInput" autocomplete="off">
      <a href="#" class="clear-button" id="clearButton">[clear]</a>
    </div>
  </div>
  <table>
    <tr>
      <th data-column="name_family" class="sorted" data-direction="asc">Directory Listing <span style="color: #0f0">↑</span></th>
    </tr>
    <script>
      let lastExpandedAttendeeId = null;
      let currentExpandedRow = null;
      let sortedAttendees = [];

      // Add this function to handle URL parameters
      function getSearchFromURL() {
        const urlParams = new URLSearchParams(window.location.hash.slice(1));
        return urlParams.get('q') || '';
      }

      fetch('./badgefile.json')
        .then(response => response.json())
        .then(data => {
          const attendees = data.attendees;
          const tbody = document.querySelector('table');
          const searchInput = document.getElementById('searchInput');
          const headers = document.querySelectorAll('th');
          const clearButton = document.getElementById('clearButton');
          const initialSearch = getSearchFromURL();

          // Move URL handling functions here where renderRows is in scope
          function updateURL(searchQuery) {
            const newURL = searchQuery 
              ? `${window.location.pathname}#q=${encodeURIComponent(searchQuery)}`
              : window.location.pathname;
            
            // Replace current history state instead of adding new one
            window.history.replaceState(null, '', newURL);
          }

          // Modify the searchInput event listener
          searchInput.addEventListener('input', (e) => {
            // If this is a user input event (not programmatic), preserve the cursor position
            const cursorPosition = e.target.selectionStart;
            const searchQuery = e.target.value;
            updateURL(searchQuery);
            renderRows(searchQuery);
            // Restore cursor position
            e.target.setSelectionRange(cursorPosition, cursorPosition);
          });

          // Show/hide clear button based on search input
          searchInput.addEventListener('input', (e) => {
            clearButton.style.display = e.target.value ? 'block' : 'none';
            renderRows(e.target.value);
          });

          // Clear button click handler
          clearButton.addEventListener('click', (e) => {
            e.preventDefault();
            searchInput.value = '';
            clearButton.style.display = 'none';
            renderRows('');
            searchInput.focus();
          });

          // 1. Simplify the field mapping and search validation
          const SEARCH_FIELDS = {
            phone: 'phone_canonical',
            id: 'badgefile_id',
            club: 'aga_chapter',
            tournament: 'tournaments_canonical',
            rating: 'aga_rating',
            language: 'languages_canonical',
            translator: 'translator',
            pid: 'primary_registrant_id',
            name: 'name'
          };

          // 2. Simplify the attendee description construction
          function buildAttendeeDescription(attendee) {
            const parts = [];
            
            if (attendee.title) parts.push(attendee.title);
            
            const age = calculateAge(new Date(attendee.date_of_birth));
            parts.push(`Age ${age}`);
            
            if (attendee.languages_canonical.length > 0) {
              const prefix = attendee.translator?.includes("Yes") ? "Translates" : "Speaks";
              parts.push(`${prefix} ${attendee.languages_canonical.map(capitalize).join('/')}`);
            }
            
            parts.push(attendee.regtype?.includes("Non-Participant") 
              ? 'non-participant'
              : `playing ${attendee.badge_rating}`);
            
            const partySize = attendees.filter(a => a.primary_registrant_id === attendee.primary_registrant_id).length;
            parts.push(partySize === 1 
              ? "solo party" 
              : attendee.badgefile_id === attendee.primary_registrant_id
                ? `primary in party of ${partySize}`
                : `party of ${partySize}`);
            
            parts.push(`${attendee.city} ${attendee.state} ${attendee.country}`);
            
            return parts.join(", ");
          }

          // 3. Simplify the matching fields display logic
          function getMatchingFields(attendee, searchTerms, fieldSearches) {
            const fields = [
              { label: 'Phone', value: attendee.phone_canonical, field: 'phone_canonical' },
              { label: 'Email', value: attendee.email },
              { label: 'AGA#', value: attendee.badgefile_id, field: 'badgefile_id' },
              { label: 'Club', value: attendee.aga_chapter, field: 'aga_chapter' },
              { label: 'Tournaments', value: (attendee.tournaments_canonical || []).join(', '), field: 'tournaments_canonical' },
              { label: 'Emerg. Contact', value: attendee.emergency_contact_name },
              { label: 'Emerg. Ph. #', value: attendee.emergency_contact_phone_std },
              { label: 'Emerg. Email', value: attendee.emergency_contact_email }
            ];

            return fields
              .filter(field => field.value && isFieldMatch(field, searchTerms, fieldSearches))
              .map(field => `
                <span style="color: #0a0">${field.label}:</span> 
                <span style="color: #0f0">
                  ${highlightText(field.value, searchTerms.join(' '), field.field, fieldSearches)}
                </span>
              `)
              .join(' | ');
          }

          // 4. Simplify the search clause parsing
          function parseSearchClauses(filterText) {
            if (!filterText) return [];
            
            return filterText.split('|').map(clause => {
              const terms = clause.match(/[^\s"']+|"([^"]*)"|'([^']*)'/g)
                ?.map(term => term.replace(/^['"]|['"]$/g, '').toLowerCase())
                .filter(Boolean) || [];
                
              return terms.reduce((acc, term) => {
                const [field, value] = term.split(':');
                if (value && SEARCH_FIELDS[field]) {
                  acc.fieldSearches.push({ field: SEARCH_FIELDS[field], value });
                } else {
                  // Preserve the quotes for exact phrase matching
                  acc.generalSearchTerms.push(term.startsWith('"') ? term : term.toLowerCase());
                }
                return acc;
              }, { fieldSearches: [], generalSearchTerms: [] });
            });
          }

          // Helper functions
          function calculateAge(birthDate) {
            const today = new Date();
            let age = today.getFullYear() - birthDate.getFullYear();
            const monthDiff = today.getMonth() - birthDate.getMonth();
            if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birthDate.getDate())) {
              age--;
            }
            return age;
          }

          function capitalize(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
          }

          function isFieldMatch(field, searchTerms, fieldSearches) {
            const fieldValue = field.value.toString().toLowerCase().trim();
            
            // Check field-specific searches
            const hasFieldMatch = fieldSearches.some(search => 
              search.field === field.field && handleSlashMatching(fieldValue, search.value)
            );
            
            if (hasFieldMatch) return true;
            
            // Check general terms
            return searchTerms.some(term => handleSlashMatching(fieldValue, term));
          }

          function handleSlashMatching(value, searchTerm) {
            value = (value || '').toString().toLowerCase().trim();
            
            // Handle quoted strings as exact matches
            if (searchTerm.startsWith('"') && searchTerm.endsWith('"')) {
              const exactPhrase = searchTerm.slice(1, -1);
              // Use word boundaries to ensure exact phrase match
              return value === exactPhrase || value.includes(` ${exactPhrase} `) || 
                     value.startsWith(`${exactPhrase} `) || value.endsWith(` ${exactPhrase}`);
            }
            
            searchTerm = searchTerm.toLowerCase().trim();
            
            if (searchTerm.startsWith('/') && searchTerm.endsWith('/')) {
              return value === searchTerm.slice(1, -1);
            } else if (searchTerm.startsWith('/')) {
              return value.startsWith(searchTerm.slice(1));
            } else if (searchTerm.endsWith('/')) {
              return value.endsWith(searchTerm.slice(0, -1));
            }
            return value.includes(searchTerm);
          }

          attendees.forEach(attendee => {
            const parts = [];
            if (attendee.title) {
              parts.push(attendee.title);
            }
            
            const birthDate = new Date(attendee.date_of_birth);
            const today = new Date();
            const age = today.getFullYear() - birthDate.getFullYear() - 
              (today.getMonth() < birthDate.getMonth() || 
               (today.getMonth() === birthDate.getMonth() && today.getDate() < birthDate.getDate()) ? 1 : 0);
            parts.push(`Age ${age}`);

            if (attendee.languages_canonical.length > 0) {
              const prefix = attendee.translator?.includes("Yes") ? "Translates" : "Speaks";
              parts.push(`${prefix} ${attendee.languages_canonical.map(lang => lang.charAt(0).toUpperCase() + lang.slice(1)).join('/')}`);
            }

            if (attendee.regtype?.includes("Non-Participant")) {
              parts.push(`non-participant`);
            } else {
              parts.push(`playing ${attendee.badge_rating}`);
            }

            // Add party size info
            const partySize = attendees.filter(a => a.primary_registrant_id === attendee.primary_registrant_id).length;
            if (partySize === 1) {
              parts.push("solo party");
            } else if (attendee.badgefile_id === attendee.primary_registrant_id) {
              parts.push(`primary in party of ${partySize}`);
            } else {
              parts.push(`party of ${partySize}`);
            }

            parts.push(`${attendee.city} ${attendee.state} ${attendee.country}`);

            attendee.description = parts.join(", ");
          });

          function sortAttendees() {
            const sortedHeader = document.querySelector('th.sorted');
            const column = sortedHeader.dataset.column;
            const direction = sortedHeader.dataset.direction === 'asc' ? 1 : -1;

            return attendees
              .filter(a => a.status.toLowerCase() !== 'cancelled')
              .sort((a, b) => {
                let aVal = a[column] || '';
                let bVal = b[column] || '';
                
                if (typeof aVal === 'string') {
                  aVal = aVal.toLowerCase();
                  bVal = bVal.toLowerCase();
                }
                
                if (aVal === bVal) {
                  return a.name_family.toLowerCase() < b.name_family.toLowerCase() ? -1 : 1;
                }
                
                return aVal < bVal ? -direction : direction;
              });
          }

          headers.forEach(header => {
            header.addEventListener('click', () => {
              headers.forEach(h => {
                if (h !== header) {
                  h.classList.remove('sorted');
                  h.dataset.direction = '';
                  h.textContent = h.textContent.replace(/[⬆️⬇️↑↓]/g, '');
                }
              });

              if (header.classList.contains('sorted')) {
                header.dataset.direction = header.dataset.direction === 'asc' ? 'desc' : 'asc';
              } else {
                header.classList.add('sorted');
                header.dataset.direction = 'asc';
              }

              header.textContent = header.textContent.replace(/[⬆️⬇️↑↓]/g, '');
              header.textContent += header.dataset.direction === 'asc' ? ' ↑' : ' ↓';

              renderRows(searchInput.value);
            });
          });

          function highlightText(text, filterText, specificField = null, fieldSearches = []) {
            text = text.toString();
            if (!filterText) return text;
            
            // Map of display fields to their canonical search fields
            const fieldMapping = {
              'tournaments': 'tournaments_canonical',
              'languages': 'languages_canonical',
              'phone': 'phone_canonical',
              'id': 'badgefile_id',
              'club': 'aga_chapter'
            };
            
            // Get general search terms
            const generalTerms = filterText.toLowerCase()
              .match(/[^\s"']+|"([^"]*)"|'([^']*)'/g)
              ?.map(term => term.replace(/^['"]|['"]$/g, '').toLowerCase())
              .filter(term => {
                return !term.includes(':') || term.split(':').length !== 2;
              }) || [];

            let termsToHighlight = [];
            
            if (specificField) {
              const fieldTerms = fieldSearches
                .filter(search => search.field === specificField)
                .map(search => search.value);
              termsToHighlight.push(...fieldTerms);
              
              if (Object.values(fieldMapping).includes(specificField)) {
                termsToHighlight.push(...generalTerms);
              }
            } else {
              termsToHighlight.push(...generalTerms);
            }
            
            if (termsToHighlight.length === 0) return text;
            
            const regex = new RegExp(
              `(${termsToHighlight.map(term => {
                // Handle prefix/suffix matching in highlighting
                let pattern = term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                if (term.startsWith('/') && !term.endsWith('/')) {
                  pattern = `^${pattern.slice(1)}`;
                } else if (term.endsWith('/') && !term.startsWith('/')) {
                  pattern = `${pattern.slice(0, -1)}$`;
                } else if (term.startsWith('/') && term.endsWith('/')) {
                  pattern = `^${pattern.slice(1, -1)}$`;
                }
                return pattern;
              }).join('|')})`,
              'gi'
            );
            return text.replace(regex, '<span class="highlight">$1</span>');
          }

          let selectedIndex = -1;

          document.addEventListener('keydown', (e) => {
            if (e.key === 'Tab') {
              e.preventDefault();
              
              // Only handle tab navigation if we have an expanded row
              if (currentExpandedRow) {
                const links = Array.from(currentExpandedRow.querySelectorAll('a'));
                const currentFocus = document.activeElement;
                const expandedTableRow = currentExpandedRow.previousElementSibling;
                
                if (links.includes(currentFocus)) {
                  // Find the next/previous link in sequence
                  const currentIndex = links.indexOf(currentFocus);
                  if (e.shiftKey) {
                    // Shift+Tab goes backward
                    if (currentIndex === 0) {
                      // If we're on first link, go back to the row
                      expandedTableRow.focus();
                    } else {
                      // Otherwise, go to previous link
                      links[currentIndex - 1]?.focus();
                    }
                  } else {
                    // Tab goes forward
                    if (currentIndex === links.length - 1) {
                      // If we're on last link, cycle back to the row
                      expandedTableRow.focus();
                    } else {
                      // Otherwise, go to next link
                      links[currentIndex + 1]?.focus();
                    }
                  }
                } else {
                  // If focus is anywhere else (including on the row)
                  if (e.shiftKey) {
                    // Shift+Tab goes to last link
                    links[links.length - 1]?.focus();
                  } else {
                    // Tab goes to first link
                    links[0]?.focus();
                  }
                }
              }
            }
          }, true);

          function handleKeyEvents(e) {
            if (e.key === 'Escape') {
              // Clear search and scroll to top
              searchInput.value = '';
              clearButton.style.display = 'none';
              renderRows('');
              window.scrollTo({ top: 0, behavior: 'smooth' });
              collapseExpandedRow();
              
              // Remove the URL anchor tag
              history.replaceState(null, '', window.location.pathname);
              
              // Remove highlight from selected row
              if (selectedIndex >= 0) {
                const rows = Array.from(tbody.getElementsByTagName('tr'))
                  .filter(row => !row.classList.contains('details') && !row.querySelector('th'));
                rows[selectedIndex].classList.remove('selected-row');
                selectedIndex = -1;
              }
              
              return;
            }

            if (e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey) {
              if (document.activeElement !== searchInput) {
                searchInput.focus();
                searchInput.value = e.key;
                renderRows(e.key);
                e.preventDefault();
              }
            }

            const rows = Array.from(tbody.getElementsByTagName('tr'))
              .filter(row => !row.classList.contains('details') && !row.querySelector('th'));

            if (rows.length === 0) return;

            let newIndex = selectedIndex;

            switch (e.key) {
              case 'Enter':
                e.preventDefault();
                if (document.activeElement.tagName === 'A') {
                  // If a link is focused, trigger its click event
                  document.activeElement.click();
                } else {
                  // Otherwise, handle row expansion/collapse if a row is selected
                  if (selectedIndex >= 0) {
                    const rows = Array.from(tbody.getElementsByTagName('tr'))
                      .filter(row => !row.classList.contains('details') && !row.querySelector('th'));
                    const detailsRow = rows[selectedIndex].nextElementSibling;
                    const arrowIndicator = rows[selectedIndex].querySelector('.arrow-indicator');
                    
                    if (detailsRow.style.display === 'table-row') {
                      detailsRow.style.display = 'none';
                      currentExpandedRow = null;
                      lastExpandedAttendeeId = null;
                      arrowIndicator.textContent = '▶';
                    } else {
                      if (currentExpandedRow) {
                        currentExpandedRow.style.display = 'none';
                        const prevRow = currentExpandedRow.previousElementSibling;
                        if (prevRow) {
                          prevRow.querySelector('.arrow-indicator').textContent = '▶';
                        }
                      }
                      detailsRow.style.display = 'table-row';
                      currentExpandedRow = detailsRow;
                      lastExpandedAttendeeId = sortedAttendees[selectedIndex].badgefile_id;
                      arrowIndicator.textContent = '▼';
                    }
                  }
                }
                return;
              case 'ArrowDown':
              case 'ArrowUp':
                // Allow default behavior (scrolling) if Shift is pressed
                if (e.shiftKey) {
                  const scrollAmount = 100; // Adjust this value to control scroll speed
                  window.scrollBy({
                    top: e.key === 'ArrowDown' ? scrollAmount : -scrollAmount,
                    behavior: 'smooth'
                  });
                  return;
                }
                
                e.preventDefault();
                
                // Calculate new index but don't clear selection if we're at the boundary
                newIndex = e.key === 'ArrowDown' 
                  ? (selectedIndex < rows.length - 1 ? selectedIndex + 1 : selectedIndex)
                  : (selectedIndex >= 0 ? (selectedIndex > 0 ? selectedIndex - 1 : selectedIndex) : 0);

                // Only clear other rows' selection if we're actually moving
                if (newIndex !== selectedIndex) {
                  rows.forEach(row => {
                    row.classList.remove('selected-row');
                    row.blur();
                  });
                }
                break;
              default:
                return;
            }

            if (newIndex !== selectedIndex || selectedIndex === -1) {
              if (selectedIndex >= 0) {
                rows[selectedIndex].classList.remove('selected-row');
              }
              
              selectedIndex = newIndex;
              rows[selectedIndex].classList.add('selected-row');
              
              // Get the current expanded state before changing rows
              const wasExpanded = currentExpandedRow?.style.display === 'table-row';
              
              rows.forEach((row, index) => {
                const detailsRow = row.nextElementSibling;
                if (index === selectedIndex && wasExpanded) {
                  detailsRow.style.display = 'table-row';
                  currentExpandedRow = detailsRow;
                  lastExpandedAttendeeId = sortedAttendees[index].badgefile_id;
                  row.querySelector('.arrow-indicator').textContent = '▼';
                } else {
                  detailsRow.style.display = 'none';
                  row.querySelector('.arrow-indicator').textContent = '▶';
                }
              });
              
              // Update scrolling behavior to align with top of viewport
              rows[selectedIndex].scrollIntoView({ block: 'start', behavior: 'smooth' });
            }
          }

          document.addEventListener('keydown', handleKeyEvents);

          function renderRows(filterText = '') {
            selectedIndex = -1;
            while (tbody.rows.length > 1) {
              tbody.deleteRow(1);
            }

            // Update the header text to include count
            const headerCell = tbody.rows[0].cells[0];
            const directionArrow = headerCell.dataset.direction === 'asc' ? ' ↑' : ' ↓';
            headerCell.innerHTML = `Directory Listing${directionArrow}`;

            // Split into OR clauses
            const clauses = filterText.split('|').map(clause => clause.trim());
            
            // Parse each clause into its search terms
            const parsedClauses = clauses.map(clause => {
              const searchTerms = clause
                .match(/[^\s"']+|"([^"]*)"|'([^']*)'/g)
                ?.map(term => term.replace(/^['"]|['"]$/g, '').toLowerCase())
                .filter(term => term.length > 0) || [];

              // Separate field-specific and general search terms for each clause
              const fieldSearches = [];
              const generalSearchTerms = [];
              
              searchTerms.forEach(term => {
                const colonIndex = term.indexOf(':');
                if (colonIndex > 0 && term.lastIndexOf(':') === colonIndex) {
                  const key = term.substring(0, colonIndex);
                  const value = term.substring(colonIndex + 1);
                  
                  const validKeys = {
                    'phone': 'phone_canonical',
                    'id': 'badgefile_id',
                    'club': 'aga_chapter',
                    'tournament': 'tournaments_canonical',
                    'rating': 'aga_rating',
                    'language': 'languages_canonical',
                    'translator': 'translator',
                    'pid': 'primary_registrant_id',
                    'name': 'name'
                  };
                  
                  if (validKeys[key]) {
                    fieldSearches.push({ field: validKeys[key], value });
                  } else {
                    generalSearchTerms.push(term);
                  }
                } else {
                  generalSearchTerms.push(term);
                }
              });

              return { fieldSearches, generalSearchTerms };
            });

            sortedAttendees = sortAttendees();
            let hasExpandedRow = false;
            let visibleCount = 0;
            let firstMatchRow = null;
            let firstMatchDetails = null;

            sortedAttendees.forEach(attendee => {
              // Check if the attendee matches ANY clause (OR logic between clauses)
              const matchesAnyClauses = parsedClauses.some(clause => {
                // For each clause, check if ALL conditions within it match (AND logic within clause)
                const fieldSearchesMatch = clause.fieldSearches.every(search => {
                  // Special handling for name field
                  if (search.field === 'name') {
                    const givenName = (attendee.name_given || '').toString().toLowerCase().trim();
                    const familyName = (attendee.name_family || '').toString().toLowerCase().trim();
                    return handleSlashMatching(givenName, search.value) || 
                           handleSlashMatching(familyName, search.value);
                  }
                  
                  // Original field search logic for other fields
                  const fieldValue = attendee[search.field];
                  if (Array.isArray(fieldValue)) {
                    // For array fields like languages_canonical
                    return fieldValue.some(v => {
                      const valueStr = (v || '').toString().toLowerCase().trim();
                      const searchStr = search.value.toLowerCase().trim();
                      
                      if (searchStr.startsWith('/') && searchStr.endsWith('/')) {
                        return valueStr === searchStr.slice(1, -1);
                      } else if (searchStr.startsWith('/')) {
                        return valueStr.startsWith(searchStr.slice(1));
                      } else if (searchStr.endsWith('/')) {
                        return valueStr.endsWith(searchStr.slice(0, -1));
                      }
                      return valueStr.includes(searchStr);
                    });
                  } else {
                    const valueStr = (fieldValue || '').toString().toLowerCase().trim();
                    const searchStr = search.value.toLowerCase().trim();
                    
                    if (searchStr.startsWith('/') && searchStr.endsWith('/')) {
                      return valueStr === searchStr.slice(1, -1);
                    } else if (searchStr.startsWith('/')) {
                      return valueStr.startsWith(searchStr.slice(1));
                    } else if (searchStr.endsWith('/')) {
                      return valueStr.endsWith(searchStr.slice(0, -1));
                    }
                    return valueStr.includes(searchStr);
                  }
                });

                if (!fieldSearchesMatch) return false;

                const searchableText = [
                  attendee.name_given || '',
                  attendee.name_family || '',
                  attendee.phone_canonical || '',
                  attendee.email || '',
                  attendee.description || '',
                  ...(attendee.languages_canonical || []),
                  ...(attendee.tournaments_canonical || []),
                  (attendee.aga_id || '').toString(),
                  attendee.aga_chapter || '',
                  attendee.emergency_contact_name || '',
                  attendee.emergency_contact_email || '',
                  attendee.emergency_contact_phone_std || ''
                ].join('\n').toLowerCase();

                return clause.generalSearchTerms.every(term => {
                  if (term.startsWith('"') && term.endsWith('"')) {
                    // For exact phrase matches, search the original text
                    return searchableText.split('\n').some(line => 
                      handleSlashMatching(line.trim(), term)
                    );
                  }
                  return handleSlashMatching(searchableText, term);
                });
              });

              // For highlighting, collect ALL search terms from ALL clauses
              const allSearchTerms = filterText ? parsedClauses.flatMap(clause => [
                ...clause.generalSearchTerms,
                ...clause.fieldSearches.map(fs => fs.value)
              ]) : [];

              const allFieldSearches = parsedClauses.flatMap(clause => clause.fieldSearches);

              if (!filterText || matchesAnyClauses) {
                visibleCount++;
                const row = document.createElement('tr');
                const name = `${highlightText(attendee.name_given || '', allSearchTerms.join(' '))} ${highlightText(attendee.name_family || '', allSearchTerms.join(' '))}`;
                const description = highlightText(attendee.description || '', allSearchTerms.join(' '));

                // Add matching fields that aren't visible in the collapsed view
                let matchingFields = [];
                if (filterText) {
                  matchingFields = getMatchingFields(attendee, allSearchTerms, allFieldSearches);
                }

                const matchingFieldsHtml = matchingFields.length 
                  ? `<div style="font-size: 14px; margin-top: 4px;">${matchingFields}</div>` 
                  : '';

                row.innerHTML = `
                  <td>
                    <span class="attendee-name">${name}</span>
                    <div style="font-size: 14px; color: #0a0; margin-top: 4px;">${description}</div>
                    ${matchingFieldsHtml}
                    <span class="arrow-indicator">▶</span>
                  </td>
                `;

                row.setAttribute('tabindex', '0');  // Make the row focusable
                
                const detailsRow = document.createElement('tr');
                detailsRow.className = 'details';
                detailsRow.innerHTML = `
                  <td>
                    <div class="details-grid">
                      <div class="details-item">
                        <div class="detail-label">Phone:</div>
                        <div class="detail-value">
                          ${highlightText(attendee.phone_canonical || 'N/A', allSearchTerms.join(' '), 'phone_canonical', allFieldSearches)}
                          ${attendee.phone_canonical ? `
                            <div style="margin-top: 4px">
                              <a href="sms:${attendee.phone_canonical}">[txt]</a>
                              <a href="tel:${attendee.phone_canonical}">[call]</a>
                            </div>
                          ` : ''}
                        </div>
                      </div>

                      <div class="details-item">
                        <div class="detail-label">Email:</div>
                        <div class="detail-value">
                          ${highlightText(attendee.email || 'N/A', allSearchTerms.join(' '))}
                          ${attendee.email ? `
                            <div style="margin-top: 4px">
                              <a href="mailto:${attendee.email}">[email]</a>
                            </div>
                          ` : ''}
                        </div>
                      </div>
                      
                      <div class="details-item">
                        <div class="detail-label">Primary Registrant:</div>
                        <div class="detail-value">
                          ${attendee.primary_registrant_name 
                            ? `${highlightText(attendee.primary_registrant_name, allSearchTerms.join(' '))} (#${
                                highlightText(attendee.primary_registrant_id, allSearchTerms.join(' '), 'primary_registrant_id', allFieldSearches)
                              })
                              <div style="margin-top: 4px">
                                <a href="#" onclick="event.preventDefault(); jumpToPrimaryRegistrant('${attendee.primary_registrant_id}')">[goto]</a>
                                ${(() => {
                                  const partyCount = attendees.filter(a => 
                                    a.primary_registrant_id === attendee.primary_registrant_id
                                  ).length;
                                  return `<a href="#" onclick="event.preventDefault(); showParty('${attendee.primary_registrant_id}')">[party (${partyCount})]</a>`;
                                })()}
                              </div>`
                            : 'N/A'
                          }
                        </div>
                      </div>

                      <div class="details-item">
                        <div class="detail-label">Emergency Contact:</div>
                        <div class="detail-value">
                          ${attendee.emergency_contact_name ? `
                            ${highlightText(attendee.emergency_contact_name, allSearchTerms.join(' '))} 
                            (${highlightText(attendee.emergency_contact_email || 'no email', allSearchTerms.join(' '))}, 
                            ${highlightText(attendee.emergency_contact_phone_std || 'no phone', allSearchTerms.join(' '))})
                          ` : 'N/A'}
                        </div>
                      </div>

                      <div class="details-item">
                        <div class="detail-label">AGA Number:</div>
                        <div class="detail-value">${highlightText(attendee.badgefile_id || 'N/A', allSearchTerms.join(' '), 'badgefile_id', allFieldSearches)}</div>
                      </div>

                      <div class="details-item">
                        <div class="detail-label">Club:</div>
                        <div class="detail-value">${highlightText(attendee.aga_chapter || 'N/A', allSearchTerms.join(' '), 'aga_chapter', allFieldSearches)}</div>
                      </div>

                      <div class="details-item">
                        <div class="detail-label">Tournaments:</div>
                        <div class="detail-value">${(attendee.tournaments_canonical || []).map(t => 
                          highlightText(t, allSearchTerms.join(' '), 'tournaments_canonical', allFieldSearches)
                        ).join(', ') || 'None'}</div>
                      </div>

                      <div class="details-item">
                        <div class="detail-label">Languages:</div>
                        <div class="detail-value">${(attendee.languages_canonical || []).map(l => 
                          highlightText(l, allSearchTerms.join(' '), 'languages_canonical', allFieldSearches)
                        ).join(', ') || 'N/A'}</div>
                      </div>
                    </div>
                  </td>
                `;

                row.querySelector('.arrow-indicator').textContent = 
                  (attendee.badgefile_id === lastExpandedAttendeeId) ? '▼' : '▶';

                if (attendee.badgefile_id === lastExpandedAttendeeId && !hasExpandedRow) {
                  detailsRow.style.display = 'table-row';
                  currentExpandedRow = detailsRow;
                  hasExpandedRow = true;
                } else {
                  detailsRow.style.display = 'none';
                }

                row.addEventListener('click', (e) => {
                  if (currentExpandedRow === detailsRow) {
                    collapseExpandedRow();
                  } else {
                    expandRow(row, detailsRow, attendee.badgefile_id);
                    row.focus();
                  }
                });

                // Store the first match we find
                if (!firstMatchRow) {
                  firstMatchRow = row;
                  firstMatchDetails = detailsRow;
                }

                tbody.appendChild(row);
                tbody.appendChild(detailsRow);
              }
            });

            headerCell.innerHTML = `Directory Listing (${visibleCount})${directionArrow}`;

            // Auto-expand if we're loading from an anchor tag and have exactly one result
            const isInitialSearch = filterText === initialSearch && initialSearch;
            if (isInitialSearch && visibleCount === 1 && firstMatchRow && firstMatchDetails) {
              // Highlight the row
              selectedIndex = 0;
              firstMatchRow.classList.add('selected-row');
              firstMatchRow.focus();

              // Expand the details
              firstMatchDetails.style.display = 'table-row';
              currentExpandedRow = firstMatchDetails;
              lastExpandedAttendeeId = sortedAttendees[0].badgefile_id;
              firstMatchRow.querySelector('.arrow-indicator').textContent = '▼';

              // Scroll to ensure the row is visible
              firstMatchRow.scrollIntoView({ block: 'start', behavior: 'smooth' });
            }
          }

          renderRows();

          searchInput.addEventListener('input', (e) => {
            renderRows(e.target.value);
          });

          const style = document.createElement('style');
          style.textContent = `
            tr:not(.details) {
              tabindex: 0;
              outline: none;
            }
            tr:not(.details):focus {
              background-color: #020;
            }
          `;
          document.head.appendChild(style);

          searchInput.addEventListener('focus', () => {
            if (window.innerWidth <= 768) {
              searchInput.closest('.search-container').classList.add('focused');
            }
          });

          // Add this event listener to handle blur events on rows
          document.addEventListener('blur', (e) => {
            if (e.target.tagName === 'TR' && !e.target.classList.contains('details')) {
              e.target.classList.remove('selected-row');
            }
          }, true);

          // Add this event listener to handle focus events on rows
          document.addEventListener('focus', (e) => {
            if (e.target.tagName === 'TR' && !e.target.classList.contains('details')) {
              // Remove selected-row class from all other rows
              const rows = Array.from(tbody.getElementsByTagName('tr'))
                .filter(row => !row.classList.contains('details') && !row.querySelector('th'));
              rows.forEach(row => {
                row.classList.remove('selected-row');
              });
            }
          });

          // Initialize with URL search query if present
          if (initialSearch) {
            searchInput.value = initialSearch;
            clearButton.style.display = 'block';
            renderRows(initialSearch);
            // Set cursor at end of initial search text
            searchInput.setSelectionRange(initialSearch.length, initialSearch.length);
          } else {
            renderRows();
          }

          function collapseExpandedRow() {
            if (currentExpandedRow) {
              currentExpandedRow.style.display = 'none';
              const prevRow = currentExpandedRow.previousElementSibling;
              if (prevRow) {
                prevRow.querySelector('.arrow-indicator').textContent = '▶';
              }
              currentExpandedRow = null;
              lastExpandedAttendeeId = null;
            }
          }

          function expandRow(row, detailsRow, attendeeId) {
            collapseExpandedRow();
            detailsRow.style.display = 'table-row';
            currentExpandedRow = detailsRow;
            lastExpandedAttendeeId = attendeeId;
            row.querySelector('.arrow-indicator').textContent = '▼';
          }

          // Add these functions at global scope so they can be called from onclick handlers
          window.showParty = function(primaryRegistrantId) {
            searchInput.value = `pid:/${primaryRegistrantId}/`;
            clearButton.style.display = 'block';
            renderRows(searchInput.value);
            updateURL(searchInput.value);
          };

          window.jumpToPrimaryRegistrant = function(primaryRegistrantId) {
            searchInput.value = `id:/${primaryRegistrantId}/`;
            clearButton.style.display = 'block';
            renderRows(searchInput.value);
            updateURL(searchInput.value);
          };
        })
        .catch(error => {
          console.error('Error loading attendee data:', error);
          document.body.innerHTML += '<p style="color: red">Error loading attendee data</p>';
        });
    </script>
  </table>
</body>
</html>
